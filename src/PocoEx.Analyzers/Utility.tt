<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace PocoEx
{
    partial class Utils
    {
<#	foreach (var entry in new [] {
			new { Symbol = "INamedTypeSymbol", Syntax = "TypeDeclarationSyntax" },
			new { Symbol = "IMethodSymbol", Syntax = "MethodDeclarationSyntax" },
			new { Symbol = "IParameterSymbol", Syntax = "ParameterSyntax" },
			new { Symbol = "IPropertySymbol", Syntax = "PropertyDeclarationSyntax" },
			new { Symbol = "IEventSymbol", Syntax = "EventDeclarationSyntax" },
		}) { #>

        /// <summary>Gets the declaration syntaxes of <see cref="<#= entry.Symbol #>"/>.</summary>
        /// <param name="symbol">The symbol to get declarations.</param>
        public static Task<IEnumerable<<#= entry.Syntax #>>> GetDeclarationSyntaxAsync(this <#= entry.Symbol #> symbol, CancellationToken cancellationToken = default(CancellationToken))
            => GetDeclarationSyntaxAsync<<#= entry.Syntax #>>(symbol, cancellationToken);
<#	} #>
<#	foreach (var declaration in new [] {
		"TypeDeclarationSyntax",
		"MethodDeclarationSyntax",
		"PropertyDeclarationSyntax",
		"EventDeclarationSyntax",
	}) { #>

        /// <summary>Gets the location of <see cref="<#= declaration #>.Identifier"/>.</summary>
        /// <param name="nodes">Nodes to get the location of the identifier.</param>
        /// <returns>The locations of the identifier.</returns>
        public static IEnumerable<Location> GetIdentifierLocations(this IEnumerable<<#= declaration #>> nodes)
			=> nodes.Select(node => node.Identifier.GetLocation());
<#	} #>
<#	foreach (var context in new [] {
		"SymbolAnalysisContext",
		"CodeBlockAnalysisContext",
	}) { #>

        /// <summary>Reports a <see cref="Diagnostic"/> related with a descriptor.</summary>
        /// <param name="context">Context to report a diagnostic.</param>
        /// <param name="descriptor">A <see cref="DiagnosticDescriptor"/> describing the diagnostic.</param>
        /// <param name="nodes">Syntax nodes related with the diagnostic.</param>
        /// <param name="messageArgs">Arguments to the message of the diagnostic</param>
        public static void ReportDiagnostic<TSyntax>(this <#= context #> context, DiagnosticDescriptor descriptor, IEnumerable<TSyntax> nodes, params object[] messageArgs)
            where TSyntax : SyntaxNode
			=> ReportDiagnostic(context, descriptor, nodes.Select(node => node.GetLocation()), messageArgs);

        /// <summary>Reports a <see cref="Diagnostic"/> related with a descriptor.</summary>
        /// <param name="context">Context to report a diagnostic.</param>
        /// <param name="descriptor">A <see cref="DiagnosticDescriptor"/> describing the diagnostic.</param>
        /// <param name="locations">An optional primary location of the diagnostic. If null, <see cref="Location"/> will return <see cref="Location.None"/>.</param>
        /// <param name="messageArgs">Arguments to the message of the diagnostic</param>
        public static void ReportDiagnostic(this <#= context #> context, DiagnosticDescriptor descriptor, IEnumerable<Location> locations, params object[] messageArgs)
        {
			var location = locations.FirstOrDefault() ?? Location.None;
            context.ReportDiagnostic(Diagnostic.Create(descriptor, location, locations.Skip(1), messageArgs));
        }
<#	} #>
    }
}